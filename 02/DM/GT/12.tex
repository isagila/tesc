\question{Деревья.}

\begin{definition}
  Дерево это связный ацикличный граф.
\end{definition}

\begin{definition}
  Лес это ацикличный граф, т.е. объединение непересекающихся деревьев.
\end{definition}

\begin{definition}
  Укорененное дерево это дерево, в котором одна из вершин обозначена корнем.
\end{definition}

\begin{definition}
  Предком вершины называется следующая вершина на кратчайшем пути к корню.
\end{definition}

\begin{definition}
  Если \(u\)~--- предок \(v\), то \(v\) называется ребенком \(u\).
\end{definition}

\begin{definition}
  Если у двух вершин один и тот же родитель, то они называются братьями.
\end{definition}

\begin{definition}
  Лист это вершина, у которой нет детей.
\end{definition}

\begin{definition}
  Вершины, не являющиеся листьями, называются внутренними.
\end{definition}

\begin{definition}
  Дерево называется \(k\)-арным, если все его вершины имеют не более \(k\)
  детей. Если \(k = 2\), то такое дерево называют бинарным.
\end{definition}

\begin{definition}
  Веткой вершины в дереве называется некоторый индуцированный подграф такой, что
  данная вершина является в нем корнем.
\end{definition}

\begin{definition}
  Вес ветки это сумма весов всех входящих в него ребер. Если дерево
  невзвешенное, то считаем вес каждого ребра равным единице.
\end{definition}

\begin{definition}
  Весом вершины называется максимальный из весов веток этой вершины.
\end{definition}

\begin{definition}
  Центроид дерева это множество вершин с минимальным весов.
\end{definition}

\begin{lemma}
  Центроид дерева содержит либо одну, либо две вершины.
\end{lemma}
\begin{proof}
  Рассмотрим невзвешенное дерево. На каждом шаге будем убирать все листья из
  текущего дерева, при этом степени оставшихся вершин будут уменьшаться на
  единицу. Будем так повторять, пока существует вершина со степенью более
  единицы.
  
  В итоге останется либо одна вершина со степенью ноль, либо две вершины со
  степенью один. Значит в исходном графе именно у этой вершины (или у этих двух
  вершин) была наименьшая степень.
\end{proof}

\begin{definition}
  Дерево называется помеченным, если каждой из его вершин соответствует
  уникальная метка от \(1\) до \(n\).
\end{definition}

\begin{definition}
  Код Прюфера эт уникальная последовательность меток от \(1\) до \(n\) длины
  \(n - 2\), которая соответствует уникальному помеченному дереву на \(n\)
  вершинах.
\end{definition}

\begin{lemma}
  Всего существует \(n^{n - 2}\) помеченных деревьев на \(n\) вершинах.
\end{lemma}
\begin{proof}
  Между деревьями на \(n\) вершинах и кодами Прюфера длина \(n -2\) действует
  биекция. Существует \(n^{n - 2}\) кодов Прюфера длины \(n - 2\).
\end{proof}

Кодирование
[\href{https://www.youtube.com/watch?v=Caqn-Vx4PoY}{визуализация}]:
\begin{enumerate}
  \item Выбираем лист с наименьшей меткой.
  \item Добавляем в ответ его родителя, после чего удаляем этот лист.
  \item Повторяем шаги \(1-2\) \(n - 2\) раза.
\end{enumerate}

Декодирование
[\href{https://www.youtube.com/watch?v=7s44l7gWEVk}{визуализация}]:
\begin{enumerate}
  \item Выписываем в строку все метки от \(1\) до \(n\).
  \item Среди выписанных меток ищем первую, которой нет в коде Прюфера.
  \item Добавляем в граф ребро между найденной меткой и первой меткой в коде
  Прюфера.
  \item Удаляем найденную метку из последовательности меток, а также удаляем
  первый элемент в коде Прюфера
  \item Повторяем шаги \(2-4\) пока не закончится код Прюфера.
  \item В последовательности останется \(2\) метки, добавляем ребро между ними.
\end{enumerate}

\begin{remark}
  Кодировать и декодировать код Прюфера можно за \(O(n)\). Алгоритм описан
  \href{https://www.scirp.org/pdf/JSEA20090200006_93737200.pdf}{здесь}.
\end{remark}