\question{Алгоритм Форда-Белмана.}

\underline{Цель}: ищем кратчайшие пути от одной вершины до всех остальных
(допускаются отрицательные ребра).

\underline{Оценка по времени}: \(O(VE)\)

\underline{Алгоритм}:
\begin{enumerate}
  \item Сделаем \(\abs{V} - 1\) итерацию (именно столько, т.к. в кратчайшем
  пути не более \(\abs{V} - 1\) ребра).
  
  \item На каждой итерации будем проходить по всем ребрам и релаксировать их.
  
  \item Релаксация ребра выглядит так: пусть дано ребро \((u, v)\).
  Тогда обновим расстояние до \(v\) следующим образом:
  \(d_{v} = \min(d_{v}, d_{u} + w_{uv})\).
\end{enumerate}

\underline{О корректности}:

Построим следующую динамику: пусть \(d[k, v]\) это длина кратчайшего пути из
стартовой вершины \(s\) в вершину \(v\), содержащего не более \(k\) ребер. Тогда
получаем:
\begin{itemize}
  \item Изначально:
  \begin{itemize}[label = \textbullet]
    \item \(\forall v \neq s \in V \colon d[0, v] = +\infty\)
    \item \(d[0, s] = 0\)
    \item \(\forall v \in V, \forall i > 0 \colon d[i, v] = +\infty\)
  \end{itemize}

  \item Переход \(d[k + 1, v] = \min \Big(
    d[k, v],
    \minL_{u \in V} (d[k, u]  + w_{uv})
  \Big)\)

  Он вытекает из следующих соображений: пусть мы хотим получить кратчайший путь
  \(s \leadsto v\), который состоит из не более чем \(k + 1\) ребра. Возможно
  два случая:

  \begin{itemize}[label = \textbullet]
    \item Можно взять длины кратчайшего пути, который состоит из не более чем
    \(k\) ребер.

    \item Можно найти путь в некоторую смежную вершину \(u\), который содержит
    не более \(k\) ребер и присоединить к нему ребро \((u, v)\). Среди всех
    таких вершин \(u\) берем такую, чтобы длина итогового пути была наименьшей.
  \end{itemize}

  Из этих двух случаев мы выбираем наименьший.
\end{itemize}

Динамика корректна по построению, а алгоритм Форда-Беллмана это следствие из
этой динамики: мы убираем индекс \(k\), чтобы оптимизировать затрачиваемую
память.
